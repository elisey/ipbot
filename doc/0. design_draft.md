# Overview

Create a small async Telegram bot (single container) that responds to `/ip` with a formatted message containing your public IP (fetched from `https://api.ipify.org`). The bot will only reply to your Telegram user ID (set in a config file). Use the **strategy pattern + factory** for IP-fetch implementations so adding alternate fetchers is trivial. Use **uv** (Astral `uv`) for running and dependency management in development. Use **Taskfile.yaml** to create convenience tasks for dev. Deploy with **Docker + docker-compose**, with `restart: always`. CI: **GitHub Actions** ‚Äî build image and push to GitHub Container Registry on merges to `main`.

---

# Project layout (recommended)

```
telegram-ip-bot/
‚îú‚îÄ .github/
‚îÇ  ‚îî‚îÄ workflows/
‚îÇ     ‚îî‚îÄ ci-docker-publish.yml
‚îú‚îÄ docker/
‚îÇ  ‚îî‚îÄ Dockerfile
‚îú‚îÄ docker-compose.yml
‚îú‚îÄ pyproject.toml
‚îú‚îÄ uv.lock (optional; produced by uv)
‚îú‚îÄ Taskfile.yaml
‚îú‚îÄ src/
‚îÇ  ‚îî‚îÄ ipbot/
‚îÇ     ‚îú‚îÄ __init__.py
‚îÇ     ‚îú‚îÄ main.py                # entrypoint: builds and runs telegram Application
‚îÇ     ‚îú‚îÄ config.py              # reads YAML/ENV config
‚îÇ     ‚îú‚îÄ bot.py                 # Telegram handlers registration
‚îÇ     ‚îú‚îÄ fetchers/
‚îÇ     ‚îÇ  ‚îú‚îÄ __init__.py
‚îÇ     ‚îÇ  ‚îú‚îÄ base.py             # FetchStrategy base class / interface
‚îÇ     ‚îÇ  ‚îú‚îÄ ipify.py            # IpifyStrategy (uses api.ipify.org)
‚îÇ     ‚îÇ  ‚îú‚îÄ ifconfigme.py       # optional alternative strategy
‚îÇ     ‚îÇ  ‚îî‚îÄ system_curl.py      # optional: uses curl subprocess (fallback)
‚îÇ     ‚îú‚îÄ factory.py             # ip fetcher factory (strategy chooser & fallback)
‚îÇ     ‚îî‚îÄ logger.py              # setup console logging
‚îú‚îÄ config/
‚îÇ  ‚îú‚îÄ config.example.yaml
‚îÇ  ‚îî‚îÄ config.yaml              # bind-mount into container or kept outside repo
‚îú‚îÄ README.md
‚îî‚îÄ .dockerignore
```

---

# Config

Use a plain YAML file `config/config.yaml` (not committed ‚Äî add config.example.yaml in repo). Example `config.example.yaml`:

```yaml
telegram:
  token: "PLACEHOLDER_BOT_TOKEN"
  owner_id: 123456789         # your Telegram user id (integer)
fetcher:
  strategy_order:
    - ipify
    - ifconfigme
    - curl
server:
  reply_format: "üåê Your public IP is: {ip}"
```

You will set the real token and owner id in `config/config.yaml` on the host, then mount it into the container at `/app/config.yaml`.

---

# Key design details

### Strategy pattern

* `base.py` defines `class FetchStrategy(ABC)` with `async def get_ip(self) -> str`.
* Each strategy implements `get_ip`:

  * `IpifyStrategy` ‚Äî HTTP GET `https://api.ipify.org?format=json` (or plain text) via `httpx` (async).
  * `IfConfigMeStrategy` ‚Äî HTTP GET `https://ifconfig.me` (or `https://ifconfig.me/ip`) ‚Äî alternative.
  * `SystemCurlStrategy` ‚Äî synchronous `subprocess` call to `curl -s https://api.ipify.org` as last resort.
* `factory.py` contains `IPFetcherFactory.create(order)` that returns a `CompositeFetcher` (tries strategies in order and returns first successful IP or raises).

### Telegram bot

* Use `python-telegram-bot` (v20+), async API:

  * `ApplicationBuilder().token(token).build()`
  * Register a `/ip` command handler that:

    1. checks `update.effective_user.id == config.owner_id` ‚Äî if not, reply `Unauthorized`.
    2. calls `fetcher.get_ip()` (async) and sends formatted message `reply_format.format(ip=ip)`.
* Run via `application.run_polling()` ‚Äî avoids webhooks and NAT complications. Polling works for home server behind NAT.

### Logging

* Console-only logging, structured, minimal. Use `logging` (INFO level). No file logs.

### Docker & docker-compose

* Dockerfile base: `python:3.14-slim`
* Build steps:

  1. set workdir `/app`
  2. copy `pyproject.toml` and `poetry.lock`/`uv.lock` if present
  3. install system deps (ca-certificates, curl ‚Äî optional), then `pip install --no-cache-dir -r requirements.txt` (or prefer installing via `pip` from `pyproject`).
  4. copy src and config.example
  5. CMD: `["/usr/local/bin/python", "-m", "ipbot.main"]` or `uv run main` for dev only.
* `docker-compose.yml` (single service `ip-bot`), mount `./config/config.yaml:/app/config.yaml:ro`, set restart policy:

```yaml
version: "3.9"
services:
  ip-bot:
    build: ./docker
    container_name: ip-bot
    restart: always
    volumes:
      - ./config/config.yaml:/app/config.yaml:ro
    environment:
      - TZ=Europe/Amsterdam
    networks:
      - default
```

> Note: Polling requires outgoing internet only (no incoming ports).

### Using `uv` in development

* `uv` will be used in `Taskfile.yaml` for local dev tasks and dependency workflows:

  * `uv init` (one-time)
  * `uv add python-telegram-bot httpx pyyaml` etc.
  * `uv run -w ipbot.main` or `uv run --with python-telegram-bot python -m ipbot.main` ‚Äî examples placed in tasks.
* `Taskfile.yaml` will define tasks like `dev`, `lint`, `format`, `build-image`, `up`, `down`, `shell`.

Example `Taskfile.yaml` (skeleton):

```yaml
version: '3'
tasks:
  dev:
    summary: Run bot locally with uv (auto-sync dependencies)
    cmds:
      - uv run --with "python-telegram-bot,httpx,pyyaml" python -m ipbot.main
  docker-build:
    cmds:
      - docker compose build
  docker-up:
    cmds:
      - docker compose up -d
  lint:
    cmds:
      - uv run --with ruff ruff check src
```

---

# pyproject / dependencies

Use a minimal `pyproject.toml` and lock via `uv`, for example:

```toml
[project]
name = "telegram-ip-bot"
version = "0.1.0"
requires-python = ">=3.14"

[project.dependencies]
python-telegram-bot = "^20.0"
httpx = "^0.24.0"
PyYAML = "^6.0"
```

(You‚Äôll use `uv add` to manage/lock deps in dev.)

---

# GitHub Actions CI (push image to GHCR)

Create `.github/workflows/ci-docker-publish.yml` that:

* runs on `pull_request` (optional) and `push` to `main` (on merge),
* checks out code,
* logs into GHCR (use `GITHUB_TOKEN` or `secrets.CR_PAT` if needed),
* builds docker image (tags: `ghcr.io/<owner>/<repo>:${{ github.sha }}` and `:latest`),
* pushes to ghcr.

Key parts:

```yaml
name: Build and publish Docker image

on:
  push:
    branches:
      - main

jobs:
  build:
    runs-on: ubuntu-latest
    permissions:
      contents: read
      packages: write
      id-token: write
    steps:
      - uses: actions/checkout@v4
      - name: Login to GHCR
        uses: docker/login-action@v2
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}
      - name: Build and push
        uses: docker/build-push-action@v5
        with:
          context: .
          file: docker/Dockerfile
          push: true
          tags: |
            ghcr.io/${{ github.repository }}:${{ github.sha }}
            ghcr.io/${{ github.repository }}:latest
```

(You can adjust permissions if you prefer a PAT; `GITHUB_TOKEN` often suffices.)

---

# Security / best practices

* `config/config.yaml` must NOT be committed. Add `config/config.yaml` to `.gitignore`.
* Use `owner_id` integer only ‚Äî the bot will ignore commands from other users.
* Keep the token out of the image ‚Äî inject via mounted config or environment variable at runtime.
* Docker image should run as non-root (optional improvement).

---

# Error handling & resiliency

* On fetch failure, try next strategy per factory. If all fail, reply with `Could not fetch public IP ‚Äî reason: <error>`.
* Catch exceptions in handler to avoid bot crash.
* Use exponential backoff / reasonable timeout for HTTP requests (e.g., 3 seconds).
* Health-check endpoints not necessary (no web server). Use container restart policy.

---

# Example flow for `/ip` command

1. User sends `/ip`.
2. Bot checks user ID ‚Üí allowed? If not: `Unauthorized`.
3. Bot calls `fetcher.get_ip()` ‚Äî `CompositeFetcher` tries `IpifyStrategy` first:

   * `IpifyStrategy` does `GET https://api.ipify.org?format=json` with `httpx.AsyncClient(timeout=3)`.
   * If success and returns `{"ip":"x.x.x.x"}` or text, parse and return.
   * Otherwise try `ifconfig.me` or `curl` fallback.
4. Bot sends reply: `üåê Your public IP is: 123.45.67.89`.
